{%- materialization test -%}
{# 
    OVERVIEW:
        This materialization handles two different test execution flows:
        1. Custom Test Flow – when `config.custom_test` is set to true, it logs test results into a centralized integrity check table.
        2. Default dbt Test Flow – fallback to dbt's standard behavior for tests.

    REQUIRED CONFIGURATION PARAMETERS:
    - custom_test (bool): Set to 'true' to enable the custom materialization logic for logging to the integrity table.
        Default: false.
    - sub_area_name (str): Required when `custom_test` is true. The subject area name associated with the test.
    - table_name_to_test (str): Required when `custom_test` is true. The name of the table being tested.
        If not provided, defaults to the dbt model's identifier.
    - generated_test_descs (list): List of test description labels to delete from the integrity check table before inserting fresh results.
    
    OUTPUTS:
        - Inserts test results into DW_DWH.DWH_D_INTEGRITY_CHECK_LU (if custom test).
        - Returns relation metadata required by dbt.

    #}
    {%- set custom_test = config.get('custom_test', default=false) -%}
    {# ------------------------ Custom Test Flow ------------------------ #}
    {# This logic runs only when `config.custom_test` is true #}
    {% if custom_test %}

        {# Retrieve configuration values necessary for logging custom test results. #}
        {% set sub_area_name = config.get('sub_area_name') %}
        {% set table_name = config.get('table_name_to_test') %}
        {% set business_date = robling_product.get_business_date() %}
        {# Get the list of test descriptions generated by the test macro (e.g., PK violations, FK violations). #}
        {% set test_descriptions_to_delete = config.get('generated_test_descs', []) %}

        {# Define the target table for storing integrity check results #}
        {% set target_relation = api.Relation.create(
            database=database,   
            schema='DW_DWH',
            identifier='DWH_F_INTEGRITY_CHK'
        ) %}
        {# Check if target table exists, if not create it using the model structure #}
        {% if not adapter.get_relation(database=target_relation.database, schema=target_relation.schema, identifier=target_relation.identifier) %}

            {# Get the rendered SQL of the integrity check model on-the-fly #}
            {% set integrity_check_model_sql = robling_product.get_rendered_sql(target_relation.identifier) %}
            
            {# Only proceed if the rendered SQL is not empty #}
            {% if integrity_check_model_sql %}
                {% call statement('create_integrity_table', auto_begin=True) %}
                    CREATE TABLE IF NOT EXISTS {{ target_relation }} AS
                    {{ integrity_check_model_sql }}
                {% endcall %}
            {% else %}
                {{ log("  Warning: Rendered SQL for integrity check model '" ~ target_relation.identifier ~ "' is empty. Table will not be created.", warn=true) }}
            {% endif %}

        {% endif %}
        {# Pre-hook: Delete existing records for the current run based on business date, subject area, table name and test description #}
        {{ log("  Deleting existing records from " ~ target_relation ~ " for current run...", info=true) }}
        {% call statement('delete_existing_records', auto_begin=True) %}
        DELETE FROM {{ target_relation }}
        WHERE LOAD_DT = '{{ business_date }}'
            AND SUB_AREA_NAME = '{{ sub_area_name }}'
            AND TABLE_NAME = '{{ table_name }}'
            {% if test_descriptions_to_delete %}
            AND TEST_DESC IN (
                {% for desc in test_descriptions_to_delete %}
                    '{{ desc }}'
                    {% if not loop.last %},{% endif %}
                {% endfor %}
            )
            {% endif %};
        {% endcall %}
        {{ log("  Delete statement executed.", info=true) }}
        {# Create a temporary relation to store the results of the main test query ONCE. #}
        {% set temp_relation_identifier = model['name'] ~ '_temp_test_table' %}
        {% set temp_relation = api.Relation.create(
            identifier=temp_relation_identifier,
            schema='DW_TMP',
            database=database,
            type='table'
        ) %}
        
        {% call statement('create_temp_relation', auto_begin=False) %}
        {# The `sql` variable here contains the compiled SQL from the test macro (e.g., run_general_integrity_checks). #}
            {{- create_table_as(temporary=True,relation=temp_relation, compiled_code=sql) -}}
        {% endcall %}

        {# Insert the new test results generated by the dbt test macro into the integrity check table.
            #}
        {{ log("  Inserting test results from " ~ temp_relation ~ " into " ~ target_relation, info=true) }}
        {%- set temp_columns = get_columns_in_relation(temp_relation) | map(attribute='name') | list | join(", ") -%}
        {%-call statement('insert_test_results', auto_begin=True)-%}
        INSERT INTO {{ target_relation }}
        ({{ temp_columns }})
        SELECT {{ temp_columns }} FROM {{ temp_relation }};
        {%-endcall-%}

        {{ log("  Fetching final test results for dbt runner from " ~ temp_relation, info=true) }}

        {# --- Emit JSON Result for callback (for integrity email) --- #}
        {% if execute %}
            {% set results = run_query("select * from "~temp_relation) %}
            {% set rows = results.rows %}
            {% set violations = [] %}
            {% for row in rows %}
                {% do violations.append({
                    "test_desc": row['TEST_DESC'],
                    "integrity_chk_violation_row_cnt": row['INTEGRITY_CHK_VIOLATION_ROW_CNT'],
                    "row_cnt": row['ROW_CNT'],
                    "pass_fail": row['PASS_FAIL'],
                    "severity": row['SEVERITY']
                }) %}
            {% endfor %}
            {% set integrity_json = {
                "sub_area_name": sub_area_name,
                "table_name": table_name,
                "business_date": business_date | string,
                "violations": violations
            } %}
            {# Here INTEGRITY_JSON_RESULT acts as the key for the json which is later captured from the 
            dbt_runner script in order to parse it and send the email  #}
            {{ log("INTEGRITY_JSON_RESULT: " ~ integrity_json | tojson) }}
        {% endif %}

        {#Logic for halting the load if any critical failures are found #}
        {% if execute %}
            {% set critical_failures_query %}
                SELECT 
                    COUNT(*) AS CRITICAL_FAILURES_COUNT,
                    LISTAGG(DISTINCT '"' || TEST_DESC || '"', ', ') AS FAILED_TESTS
                FROM {{ temp_relation }}
                WHERE SEVERITY = 'Critical' AND PASS_FAIL = 'Fail'
            {% endset %}

            {% set results = run_query(critical_failures_query) %}
            {% set critical_count = results.columns['CRITICAL_FAILURES_COUNT'].values()[0] %}

            {% if critical_count > 0 %}
                {% set failed_tests_list = results.columns['FAILED_TESTS'].values()[0] %}
                {{ exceptions.raise_compiler_error(
                    "CRITICAL FAILURE: Found " ~ critical_count ~ " critical test(s) failed for table '" ~ table_name ~ "'. Failing tests: " ~ failed_tests_list ~ ". Halting execution."
                ) }}
            {% endif %}
        {% endif %}
        {#
          This block runs AFTER the load to integrity check table. Its only purpose is to
          return the 1-row, 3-column result set that the dbt test runner expects.
          It now reads from the temporary relation created earlier.
        #}
        {%-call statement('main', fetch_result=True) -%}
            SELECT
                -- 1. Count the number of failures
                COUNT(*) AS failures,
                -- 2. Check if the failure count should trigger a warning
                CASE
                    WHEN COUNT(*) {{ config.get('warn_if', default='!= 0') }} THEN 1
                    ELSE 0
                END AS should_warn,
                -- 3. Check if the failure count should trigger an error
                CASE
                    WHEN COUNT(*) {{ config.get('error_if', default='!= 0') }} THEN 1
                    ELSE 0
                END AS should_error
            FROM {{ temp_relation }}
            -- Filter on failure results only
            WHERE PASS_FAIL = 'Fail'
        {%- endcall %}
        {# --------------------------------------------------------------- #}

        {{ adapter.commit() }}
        {# Clean up the temporary relation at the end of the run #}
        {{ log("Dropping temporary relation: " ~ temp_relation, info=true) }}
        {% do adapter.drop_relation(temp_relation) %}
        {# For dbt's internal tracking, return the target relation where failures *could* have been stored
            if `should_store_failures()` was true in the default flow. In this custom flow, we are logging
            to a predefined table, but dbt still expects a `relations` list. #}
        {% do return({'relations': [target_relation]}) %}

    {# ------------------------ Default Test Flow ------------------------ #}
    {# If `custom_test` is not true, run the original default dbt test materialization. #}
    {# This code is copied directly from dbt's default implementation. #}
    {% else %}

        {% set relations = [] %}

        {% if should_store_failures() %}

            {% set identifier = model['alias'] %}
            {% set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) %}

            {% set store_failures_as = config.get('store_failures_as') %}
            -- if `--store-failures` is invoked via command line and `store_failures_as` is not set,
            -- config.get('store_failures_as', 'table') returns None, not 'table'
            {% if store_failures_as == none %}{% set store_failures_as = 'table' %}{% endif %}
            {% if store_failures_as not in ['table', 'view','incremental'] %}
                {{ exceptions.raise_compiler_error(
                    "'" ~ store_failures_as ~ "' is not a valid value for `store_failures_as`. "
                    "Accepted values are: ['ephemeral', 'table', 'view']"
                ) }}
            {% endif %}

            {% set target_relation = api.Relation.create(
                identifier=identifier, schema=schema, database=database, type=store_failures_as) -%} %}

            {% if old_relation %}
                {% do adapter.drop_relation(old_relation) %}
            {% endif %}

            {% call statement(auto_begin=True) %}
                {{ get_create_sql(target_relation, sql) }}
            {% endcall %}

            {% do relations.append(target_relation) %}

            {% set main_sql %}
                select *
                from {{ target_relation }}
            {% endset %}

            {{ adapter.commit() }}

        {% else %}

            {% set main_sql = sql %}

        {% endif %}

        {% set limit = config.get('limit') %}
        {% set fail_calc = config.get('fail_calc') %}
        {% set warn_if = config.get('warn_if') %}
        {% set error_if = config.get('error_if') %}

        {% call statement('main', fetch_result=True) -%}

            {{ get_test_sql(main_sql, fail_calc, warn_if, error_if, limit)}}

        {%- endcall %}

        {{ return({'relations': relations}) }}
    {% endif %}

{%- endmaterialization -%}
